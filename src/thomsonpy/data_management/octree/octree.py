# -*- coding: utf-8 -*-
"""octree.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10SW02kY8czbkvYbl7bhd4ac8C4HRAdp5
"""

import numpy as np
import open3d as o3d
import pickle
import sys

class Data:
    def __init__(self, coordinates, ne):
        self.__coordinates = coordinates
        self.__ne = ne

    def __str__(self):
        return 'Data = {} at ({}, {}, {})'.format(self.__ne, self.__coordinates[0], self.__coordinates[1], self.__coordinates[2])

    def get_coordinates(self):
        return self.__coordinates

    def get_x(self):
        return self.__coordinates[0]

    def get_y(self):
        return self.__coordinates[1]

    def get_z(self):
        return self.__coordinates[2]

    def get_ne(self):
        return self.__ne

class Node:

    def __init__(self, level, ant, min, max, octree):
        self.__antecessor = ant
        self.__level = level
        self.__children = list()
        self.__octree = octree
        self.__min = min
        self.__max = max
        self.__data = list()

    def __str__(self):
        return 'Node at level {} with {} data at coordinates {} and {}. Total data:{}.'.format(self.__level, len(self.__data), self.__min, self.__max, len(self.__data))

    def __create_children(self):
        self.__children = [None] * 8

        min_x = self.__min[0]
        min_y = self.__min[1]
        min_z = self.__min[2]
        max_x = self.__max[0]
        max_y = self.__max[1]
        max_z = self.__max[2]
        mid_x = (max_x + min_x) / 2
        mid_y = (max_y + min_y) / 2
        mid_z = (max_z + min_z) / 2

        self.__children[0] = Node(self.__level + 1, self, np.array([min_x, min_y, min_z]), 
                                  np.array([mid_x, mid_y, mid_z]), self.__octree)

        self.__children[1] = Node(self.__level + 1, self, np.array([mid_x, min_y, min_z]), 
                                  np.array([max_x, mid_y, mid_z]), self.__octree)

        self.__children[2] = Node(self.__level + 1, self, np.array([mid_x, mid_y, min_z]), 
                                  np.array([max_x, max_y, mid_z]), self.__octree)

        self.__children[3] = Node(self.__level + 1, self, np.array([min_x, mid_y, min_z]), 
                                  np.array([mid_x, max_y, mid_z]), self.__octree)

        self.__children[4] = Node(self.__level + 1, self, np.array([min_x, min_y, mid_z]), 
                                  np.array([mid_x, mid_y, max_z]), self.__octree)

        self.__children[5] = Node(self.__level + 1, self, np.array([mid_x, min_y, mid_z]), 
                                  np.array([max_x, mid_y, max_z]), self.__octree)

        self.__children[6] = Node(self.__level + 1, self, np.array([mid_x, mid_y, mid_z]), 
                                  np.array([max_x, max_y, max_z]), self.__octree)

        self.__children[7] = Node(self.__level + 1, self, np.array([min_x, mid_y, mid_z]), 
                                  np.array([mid_x, max_y, max_z]), self.__octree)
    
    def add(self, data):
        if len(self.__children) == 0:
            if self.__level == self.__octree.get_level_limit() or len(self.__data) < self.__octree.get_data_limit():
                self.__data.append(data)
            else:
                self.__data.append(data)
                self.__create_children()
                for p in self.__data:
                    for c in self.__children:
                        if c.contains(p):
                            c.add(p)
                self.__data.clear()
        else:
            for c in self.__children:
                if c.contains(data):
                    c.add(data)

    def search(self, data):
        if len(self.__children) != 0 and self.contains(data):
            for c in self.__children:
                if c.contains(data):
                    return c.search(data)
        else:
            return self
        return None

    def search_nearest(self, p):
        if len(self.__children) != 0 and self.inside(p):
            for c in self.__children:
                if c.inside(p):
                    return c.search_nearest(p)
        else:
            nearest = None
            min_distance = sys.float_info.max
            for data in self.__data:
                distance = np.linalg.norm(p - data.get_coordinates())
                if distance < min_distance:
                    nearest = data
                    distance = min_distance
            return nearest
        return None

    def inside(self, p):
        x = p[0]
        y = p[1]
        z = p[2]        
        return x < self.__max[0] and y < self.__max[1] and z < self.__max[2] and x >= self.__min[0] and y >= self.__min[1] and z >= self.__min[2]
    
    def contains(self, data):
        x = data.get_x()
        y = data.get_y()
        z = data.get_z()
        return x < self.__max[0] and y < self.__max[1] and z < self.__max[2] and x >= self.__min[0] and y >= self.__min[1] and z >= self.__min[2]

    def get_min(self):
        return self.__min

    def get_max(self):
        return self.__max

    def get_data(self):
        return self.__data

    def get_num_points(self):
        return len(self.__data)

    def has_children(self):
        return len(self.__children) != 0

    def has_data(self):
        return len(self.__data) != 0

    def get_level(self):
        return self.__level

    def see_node(self):
        min_x = self.__min[0]
        min_y = self.__min[1]
        min_z = self.__min[2]
        max_x = self.__max[0]
        max_y = self.__max[1]
        max_z = self.__max[2]
        points = [
            [min_x, min_y, min_z],
            [max_x, min_y, min_z],
            [min_x, max_y, min_z],
            [max_x, max_y, min_z],
            [min_x, min_y, max_z],
            [max_x, min_y, max_z],
            [min_x, max_y, max_z],
            [max_x, max_y, max_z],
            ]
        lines = [
            [0, 1],
            [0, 2],
            [1, 3],
            [2, 3],
            [4, 5],
            [4, 6],
            [5, 7],
            [6, 7],
            [0, 4],
            [1, 5],
            [2, 6],
            [3, 7],
        ]
        line_set = o3d.geometry.LineSet(
        points=o3d.utility.Vector3dVector(points),
        lines=o3d.utility.Vector2iVector(lines),
        )

        if (self.__level >= 0):
        #if (self.has_data()):
            self.__octree.visual_nodes.append(line_set)
        for c in self.__children:
            c.see_node()

class Octree:

    def __init__(self, level_limit, data_limit, data, min_v, max_v):
        self.__min = min_v
        self.__max = max_v
        self.__level_limit = level_limit
        self.__data_limit = data_limit
        self.__num_data = len(data)
        self.__root = Node(0, None, self.__min, self.__max, self)
        progress = 0
        total = len(data)
        for p in data:
            self.__root.add(p)
            # progress...
            if progress % 100000 == 0:
                print(progress / total * 100, "%")
            progress += 1
        self.visual_nodes = list()

    def search(self, data):
        return self.__root.search(data)
    
    def search_nearest(self, p):
        return self.__root.search_nearest(p)

    def get_level_limit(self):
        return self.__level_limit

    def get_data_limit(self):
        return self.__data_limit

    def get_num_data(self):
        return self.__num_data

    def get_root(self):
        return self.__root

    def get_visual_octree(self):
        self.__root.see_node()
        return self.visual_nodes

    @staticmethod
    def save(octree, filename):
        f = open(filename, 'wb')
        pickle.dump(octree, f)
        f.close()

    @staticmethod
    def load(filename):
        f = open(filename, 'rb')
        obj = pickle.load(f)
        f.close()
        return obj